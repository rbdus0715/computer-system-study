## 1.1 정보는 비트 & 컨텍스트
- hello 프로그램은 hello.c라는 텍스트 파일을 통해 생성됨.
- 소스 프로그램은  0/1 비트의 연속, 8비트 단위(1바이트)로 구성
- 아스키 표준(ASCII)은 각 문자를 바이트 길이(2^8 = 256가지)의 정수값으로 나타냄
- **텍스트 파일**: 아스키 문자들로만 이루어진 파일 / **바이너리 파일**: 다른 모든 파일
- 객체 구분 방법은 이를 바라보는 컨텍스트에 의해서!

## 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역됨
- C 프로그램 실행 > 각 문장들 - 다른 프로그램에 의해 저급 기계어 인스트럭션들로 번역 > '실행 가능 목적 프로그램' 형태(바이너리 디스크 파일로 저장)
```bash
gcc -o hello hello.c
```
- 컴파일 시스템(4단계): 전처리기 - 컴파일러 - 어셈블러 - 링커

| 과정 | 역할 | 결과 |
|---|----|-----|
|전처리 단계 | #문자로 시작하는 지시어(directive)를 전부 실제 코드로 대치 |hello.i 텍스트 파일|
|컴파일 단계 | hello.i를 어셈블리어가 담긴 hello.s 텍스트파일로 변환, main 함수 정의를 포함 | hello.s 어셈블리어 프로그램(txt) |
|어셈블리 단계 | 어셈블러가 hello.s를 기계어 인스트럭션으로 번역, 재배치가능 목적프로그램의 형태로 묶음 | hello.o 바이너리 파일 |
|링크 단계| printf 함수는 이미 컴파일된 별도의 목적파일(printf.o)에 있음 - 링커프로그램이 hello.o와 결합 | 실행가능 목적파일(실행파일) |

## 1.3 컴파일 시스템 동작 원리 이해의 중요성
- 프로그램 성능 최적화 (3장, 5장, 6장)
  - switch vs if-else
  - 포인터 참조 vs 배열 인덱스
  - 함수 호출 시 발생하는 오버헤드는 얼마
  - while vs for
  - 합계를 지역변수에 저장 + 루프 vs 참조형태로 넘겨받은 인자 사용 + 루프
  - 수식 연산 시 괄호 재배치 최적화
- 링크 에러 이해 (7장)
  - 링커가 참조를 풀어낼 수 없다는 건 뭔 뜻?
  - 정적변수 vs 전역변수
  - 각기 다른 파일에 동일한 이름의 전역변수 정의하면?
  - 정적 라이브러리 vs 동적 라이브러리
  - 컴파일 명령을 쉘에서 입력 시 명령어 라인의 라이브러리들의 순서의 의미
  - 링커 에러는 실행 전에는 나타나지 않는 이유
- 보안 약점 피하기 (3장)
  - 오버플로우 취약성
  - 프로그램 스택에 데이터와 제어 정보가 저장되는 방식으로 생기는 영향 이해

## 1.4 프로세서: 메모리에 저장된 인스트럭션 읽고 해석
시스템 하드웨어 조직
|요소|역할|챕터|
|---|---|---|
|버스|컴포넌트 간 바이트 정보 전송 역할|
|워드| (버스에서 전송 시) 고정 크기의 바이트 단위, 오늘날: 4바이트(32비트) or 8바이트(64비트)|
|입출력 장치| 시스템과 외부세계와의 연결 담당(키보드, 마우스, 디스플레이 등) - 입출력 벼스와 컨트롤러 or 어댑터로 장치들 간의 정보 전송 |6장, 10장|
|메인 메모리| 프로세서가 프로그램 실행하는 동안 데이터, 프로그램을 모두 저장하는 임시 저장장치 - DRAM 칩들로 구성|6장|
|프로세서|주처리장치(CPU), 메인 메모리에 저장된 인스트럭션 해독, 워드 크기의 저장장치인 프로그램 카운터(PC) 있음, PC가 가리키는 메모리로부터 인스트럭션 읽어오고 - 다음 인스트럭션 위치로 PC를 업데이트(포인터같은 역할인듯)|3장, 4장, 5장|


cpu가 하는 단순 작업
- 적재: 메인 메모리 > 레지스터에 한 바이트 or 워드를 이전 값에 덮어쓰는 방식으로 복사
- 저장: 레지스터에서 메인 메모리로 한 바이트 or 워드를 이전  값을 덮어쓰는 방식으로 복사
- 작업: 두 레지스터 값을 ALU로 복사, 두 개의 워드로 수식연산 수행, 결과를 레지스터에 저장
- 점프: 인스트럭션 자신으로부터 한 개의 워드를 추출, 이것을 PC에 덮어쓰기 방식으로 복사

hello 프로그램 실행 및 동작 과정
1. shell에서 ./hello 입력
2. hello 프로그램 목적파일의 코드와 데이터가 디스크에서 메인 메모리로 로딩 (직접 메모리 접근, DMA)
3. 프로세서가 hello의 main 루틴의 기계어 인스트럭션 실행
4. "hello, world\n" 스트링을 메모리로부터 레지스터 파일로 복사
5. 거기서 디스플레이 장치로 전송, 화면에 글자 표시

## 1.5 캐시의 중요성
- 정보가 다른 곳으로 이동(복사)하는 것이 시간 많이 걸림 > 오버헤드
- 저장공간이 클수록 비용, 속도 측면 단점 증가
- 레지스터 파일(중간결과 임시저장)은 수백 바이트 정보 저장, 메인 메모리는 십억 개 바이트 저장
- 프로세서는 레지스터 파일의 데이터 읽는 것이 메모리 데이터 읽는 것보다 100배 더 빠름
- 프로세서-메모리 간 격차 대응 > 카시 메모리: 프로세서가 단기간에 필요로 할 가능성이 높은 정보 임시 저장할 목적 (L1, L2 캐시)
- L1, L2 캐시는 SRAM 기술 사용

## 1.6 계층구조를 이루는 저장장치


## 1.7 운영체제는 하드웨어를 관리함

## 1.8 시스템은 네트워크를 통해 다른 시스템과 통신함

## 1.9 etc.