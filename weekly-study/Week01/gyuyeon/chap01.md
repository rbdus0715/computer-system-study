## 1.1 정보는 비트 & 컨텍스트
- hello 프로그램은 hello.c라는 텍스트 파일을 통해 생성됨.
- 소스 프로그램은  0/1 비트의 연속, 8비트 단위(1바이트)로 구성
- 아스키 표준(ASCII)은 각 문자를 바이트 길이(2^8 = 256가지)의 정수값으로 나타냄
- **텍스트 파일**: 아스키 문자들로만 이루어진 파일 / **바이너리 파일**: 다른 모든 파일
- 객체 구분 방법은 이를 바라보는 컨텍스트에 의해서!

## 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역됨
- C 프로그램 실행 > 각 문장들 - 다른 프로그램에 의해 저급 기계어 인스트럭션들로 번역 > '실행 가능 목적 프로그램' 형태(바이너리 디스크 파일로 저장)
```bash
gcc -o hello hello.c
```
- 컴파일 시스템(4단계): 전처리기 - 컴파일러 - 어셈블러 - 링커

| 과정 | 역할 | 결과 |
|---|----|-----|
|전처리 단계 | #문자로 시작하는 지시어(directive)를 전부 실제 코드로 대치 |hello.i 텍스트 파일|
|컴파일 단계 | hello.i를 어셈블리어가 담긴 hello.s 텍스트파일로 변환, main 함수 정의를 포함 | hello.s 어셈블리어 프로그램(txt) |
|어셈블리 단계 | 어셈블러가 hello.s를 기계어 인스트럭션으로 번역, 재배치가능 목적프로그램의 형태로 묶음 | hello.o 바이너리 파일 |
|링크 단계| printf 함수는 이미 컴파일된 별도의 목적파일(printf.o)에 있음 - 링커프로그램이 hello.o와 결합 | 실행가능 목적파일(실행파일) |

## 1.3 컴파일 시스템 동작 원리 이해의 중요성
- 프로그램 성능 최적화 (3장, 5장, 6장)
  - switch vs if-else
  - 포인터 참조 vs 배열 인덱스
  - 함수 호출 시 발생하는 오버헤드는 얼마
  - while vs for
  - 합계를 지역변수에 저장 + 루프 vs 참조형태로 넘겨받은 인자 사용 + 루프
  - 수식 연산 시 괄호 재배치 최적화
- 링크 에러 이해 (7장)
  - 링커가 참조를 풀어낼 수 없다는 건 뭔 뜻?
  - 정적변수 vs 전역변수
  - 각기 다른 파일에 동일한 이름의 전역변수 정의하면?
  - 정적 라이브러리 vs 동적 라이브러리
  - 컴파일 명령을 쉘에서 입력 시 명령어 라인의 라이브러리들의 순서의 의미
  - 링커 에러는 실행 전에는 나타나지 않는 이유
- 보안 약점 피하기 (3장)
  - 오버플로우 취약성
  - 프로그램 스택에 데이터와 제어 정보가 저장되는 방식으로 생기는 영향 이해

## 1.4 프로세서: 메모리에 저장된 인스트럭션 읽고 해석
시스템 하드웨어 조직
|요소|역할|챕터|
|---|---|---|
|버스|컴포넌트 간 바이트 정보 전송 역할|
|워드| (버스에서 전송 시) 고정 크기의 바이트 단위, 오늘날: 4바이트(32비트) or 8바이트(64비트)|
|입출력 장치| 시스템과 외부세계와의 연결 담당(키보드, 마우스, 디스플레이 등) - 입출력 벼스와 컨트롤러 or 어댑터로 장치들 간의 정보 전송 |6장, 10장|
|메인 메모리| 프로세서가 프로그램 실행하는 동안 데이터, 프로그램을 모두 저장하는 임시 저장장치 - DRAM 칩들로 구성|6장|
|프로세서|주처리장치(CPU), 메인 메모리에 저장된 인스트럭션 해독, 워드 크기의 저장장치인 프로그램 카운터(PC) 있음, PC가 가리키는 메모리로부터 인스트럭션 읽어오고 - 다음 인스트럭션 위치로 PC를 업데이트(포인터같은 역할인듯)|3장, 4장, 5장|


cpu가 하는 단순 작업
- 적재: 메인 메모리 > 레지스터에 한 바이트 or 워드를 이전 값에 덮어쓰는 방식으로 복사
- 저장: 레지스터에서 메인 메모리로 한 바이트 or 워드를 이전  값을 덮어쓰는 방식으로 복사
- 작업: 두 레지스터 값을 ALU로 복사, 두 개의 워드로 수식연산 수행, 결과를 레지스터에 저장
- 점프: 인스트럭션 자신으로부터 한 개의 워드를 추출, 이것을 PC에 덮어쓰기 방식으로 복사

hello 프로그램 실행 및 동작 과정
1. shell에서 ./hello 입력
2. hello 프로그램 목적파일의 코드와 데이터가 디스크에서 메인 메모리로 로딩 (직접 메모리 접근, DMA)
3. 프로세서가 hello의 main 루틴의 기계어 인스트럭션 실행
4. "hello, world\n" 스트링을 메모리로부터 레지스터 파일로 복사
5. 거기서 디스플레이 장치로 전송, 화면에 글자 표시

## 1.5 캐시의 중요성
- 정보가 다른 곳으로 이동(복사)하는 것이 시간 많이 걸림 > 오버헤드
- 저장공간이 클수록 비용, 속도 측면 단점 증가
- 레지스터 파일(중간결과 임시저장)은 수백 바이트 정보 저장, 메인 메모리는 십억 개 바이트 저장
- 프로세서는 레지스터 파일의 데이터 읽는 것이 메모리 데이터 읽는 것보다 100배 더 빠름
- 프로세서-메모리 간 격차 대응 > 카시 메모리: 프로세서가 단기간에 필요로 할 가능성이 높은 정보 임시 저장할 목적 (L1, L2 캐시)
- L1, L2 캐시는 SRAM 기술 사용

## 1.6 저장장치 계층구조
- L0: 레지스터 파일
- L1~L3: 캐시 사용
- L4: 메인 메모리

메모리 계층구조 아이디어: 한 레벨의 저장장치가 다음 하위레벨 저장장치의 캐시 역할

## 1.7 운영체제는 하드웨어를 관리함
운영체제
- hello 프로그램은 직접 디스크/메인메모리에 접근 X
- 운영체제의 API 사용

운영체제의 목적
1. 제멋대로 동작하는 으용프로그램들이 하드웨어 잘못 사용하는 것을 막기 위해
2. 응용프로그램이 단순 메커니즘을 사용해 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작하도록

프로세스 (8장)
- 멀티코어 프로세서 > 여러 개의 프로그램 동시 실행
- 운영 체제의 context switching: 교차실행
- 프로세스 전환은 운영체제 커널에 의해 관리됨
- 응용프로그램이 운영체제에 의한 어떤 작업 요청 > 컴퓨터는 파일 읽기나 쓰기와 같은 특정 시스템 콜을 실행 > 커널에 제어 넘겨줌

쓰레드 (12장)
- 프로세스는 쓰레드(다수의 실행 유닛)로 구성됨
- 각 쓰레드는 해당 프로세스의 컨텍스트에서 실행되고 동일한 코드/전역 데이터 공유
다수의 프로세서들에서보다 데이터 공유가 더 쉬움, 쓰레드가 더 효율적

가상메모리 (9장)
- 프로그램 코드 & 데이터: 목적파일로부터 직접 초기화됨
- 힙: 동적 할당
- 공유 라이브러리: 공유 라이브러리 코드, 데이터 저장
- 스택: 컴파일러가 함수 호출을 구현하기 위해 사용
- 커널 가상메모리: 커널을 위해 예약된 공간

파일: 연속된 바이트들

## 1.8 시스템은 네트워크를 통해 다른 시스템과 통신함
- 네트워크는 단지 또 다른 입출력 장치
- telnet 응용 > hello 프로그램을 다른 곳에 위치한 컴퓨터에서 실행 가능
- 네트워크는 11장에서

## 1.9 etc.
Amdahl 법칙
- 시스템의 한 부분 성능 개선 시, 전체 시스템 성능에 대한 효과: 그 부분의 중요도, 얼마나 빨라졌는가와 관계됨
- 전체 시스템을 상당히 빠르게 하려면 전체 시스템의 매우 큰 부분의 성능을 개선해야함

동시성과 병렬성
- 쓰레드 수준 병렬성
  - 멀티프로세서 시스템: 여러 개의 프로세서 > 하나의 운영체제 커널의 제어로 동작
  - 멀티코어 프로세서: 여러 CPU를 하나의 칩에 내장
  - 멀티쓰레딩(하이퍼쓰레딩): 하나의 CPU가 여러 제어 흐름을 실행할 수 있게 해주는 기술
- 인스트럭션 수준 병렬성
  - 여러 개의 인스트럭션을 한 번에 실행
  - 최근 프로세서는 매 클럭마다 2.4개 인스트럭션 실행
  - 슈퍼스케일러: 사이클당 한 개 이상의 인스트럭션을 실행할 수 있는 프로세서
- 싱글 인스트럭션, 다중 데이터 벙렬성(SIMD)
  - 한 인스트럭션이 병렬로 다수의 연산 수행

컴퓨터 시스템에서 추상화의 중요성
- 인스트럭션 셋은 실제 프로세서 하드웨어의 추상화를 제공
