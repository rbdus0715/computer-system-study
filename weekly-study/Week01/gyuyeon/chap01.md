## 1.1 정보는 비트 & 컨텍스트
- hello 프로그램은 hello.c라는 텍스트 파일을 통해 생성됨.
- 소스 프로그램은  0/1 비트의 연속, 8비트 단위(1바이트)로 구성
- 아스키 표준(ASCII)은 각 문자를 바이트 길이(2^8 = 256가지)의 정수값으로 나타냄
- **텍스트 파일**: 아스키 문자들로만 이루어진 파일 / **바이너리 파일**: 다른 모든 파일
- 객체 구분 방법은 이를 바라보는 컨텍스트에 의해서!

## 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역됨
- C 프로그램 실행 > 각 문장들 - 다른 프로그램에 의해 저급 기계어 인스트럭션들로 번역 > '실행 가능 목적 프로그램' 형태(바이너리 디스크 파일로 저장)
```bash
gcc -o hello hello.c
```
- 컴파일 시스템(4단계): 전처리기 - 컴파일러 - 어셈블러 - 링커

| 과정 | 역할 | 결과 |
|---|----|-----|
|전처리 단계 | #문자로 시작하는 지시어(directive)를 전부 실제 코드로 대치 |hello.i 텍스트 파일|
|컴파일 단계 | hello.i를 어셈블리어가 담긴 hello.s 텍스트파일로 변환, main 함수 정의를 포함 | hello.s 어셈블리어 프로그램(txt) |
|어셈블리 단계 | 어셈블러가 hello.s를 기계어 인스트럭션으로 번역, 재배치가능 목적프로그램의 형태로 묶음 | hello.o 바이너리 파일 |
|링크 단계| printf 함수는 이미 컴파일된 별도의 목적파일(printf.o)에 있음 - 링커프로그램이 hello.o와 결합 | 실행가능 목적파일(실행파일) |

## 1.3 컴파일 시스템 동작 원리 이해의 중요성
- 프로그램 성능 최적화 (3장, 5장, 6장)
  - switch vs if-else
  - 포인터 참조 vs 배열 인덱스
  - 함수 호출 시 발생하는 오버헤드는 얼마
  - while vs for
  - 합계를 지역변수에 저장 + 루프 vs 참조형태로 넘겨받은 인자 사용 + 루프
  - 수식 연산 시 괄호 재배치 최적화
- 링크 에러 이해 (7장)
  - 링커가 참조를 풀어낼 수 없다는 건 뭔 뜻?
  - 정적변수 vs 전역변수
  - 각기 다른 파일에 동일한 이름의 전역변수 정의하면?
  - 정적 라이브러리 vs 동적 라이브러리
  - 컴파일 명령을 쉘에서 입력 시 명령어 라인의 라이브러리들의 순서의 의미
  - 링커 에러는 실행 전에는 나타나지 않는 이유
- 보안 약점 피하기 (3장)
  - 오버플로우 취약성
  - 프로그램 스택에 데이터와 제어 정보가 저장되는 방식으로 생기는 영향 이해

## 1.4 프로세서: 메모리에 저장된 인스트럭션 읽고 해석
- 시스템 하드웨어 조직
  - 버스: 컴포넌트 간 바이트 정보 전송 역할
  - 워드: (버스에서 전송 시) 고정 크기의 바이트 단위, 오늘날: 4바이트(32비트) or 8바이트(64비트)
  - 입출력 장치: 시스템과 외부세계와의 연결 담당(키보드, 마우스, 디스플레이 등)
  - 메인 메모리
  - 프로세서
  - 점프
- hello 프로그램 실행